#!/usr/bin/env node

/**
 * üéÆ MANUAL BACKUP SYSTEM
 * Script backup th·ªß c√¥ng v·ªõi menu t∆∞∆°ng t√°c cho Trading Journal
 * Version: 2.0 - Chu·∫©n h√≥a v√† t·ªëi ∆∞u
 */

const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');
const readline = require('readline');

const execAsync = promisify(exec);

class ManualBackupSystem {
  constructor() {
    this.backupBaseDir = path.join(process.cwd(), 'backups');
    this.loadEnvironment();
    this.dbConfig = this.parseDbUrl(process.env.DATABASE_URL);
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    // C·∫•u h√¨nh backup
    this.config = {
      compressionLevel: 9,
      maxBackupAge: 30, // ng√†y
      criticalFiles: [
        '.env',
        'package.json',
        'package-lock.json',
        'prisma/schema.prisma',
        'next.config.js'
      ],
      backupDirs: [
        { src: 'public/uploads', dest: 'uploads', required: false },
        { src: 'public/images', dest: 'images', required: false },
        { src: 'prisma', dest: 'prisma', required: true }
      ]
    };
  }

  /**
   * Load environment variables t·ª´ .env file
   */
  loadEnvironment() {
    const envPath = path.join(process.cwd(), '.env');
    if (fs.existsSync(envPath)) {
      const envContent = fs.readFileSync(envPath, 'utf-8');
      const envLines = envContent.split('\n');
      
      for (const line of envLines) {
        const trimmed = line.trim();
        if (trimmed && !trimmed.startsWith('#') && trimmed.includes('=')) {
          const [key, ...valueParts] = trimmed.split('=');
          const value = valueParts.join('=').replace(/^["']|["']$/g, '');
          process.env[key.trim()] = value;
        }
      }
    }
  }

  /**
   * Parse DATABASE_URL th√†nh c√°c component
   */
  parseDbUrl(url) {
    if (!url) {
      throw new Error('DATABASE_URL kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh trong .env');
    }
    
    const match = url.match(/postgresql:\/\/([^:]+):([^@]+)@([^:]+):(\d+)\/(.+)/);
    if (!match) {
      throw new Error('DATABASE_URL kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng PostgreSQL');
    }
    
    return {
      user: match[1],
      password: match[2],
      host: match[3],
      port: match[4],
      database: match[5]
    };
  }

  /**
   * Utility functions
   */
  async question(prompt) {
    return new Promise(resolve => {
      this.rl.question(prompt, resolve);
    });
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  getAge(date) {
    const now = new Date();
    const diffMs = now - date;
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    const diffHours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    
    if (diffDays > 0) {
      return `${diffDays} ng√†y`;
    } else if (diffHours > 0) {
      return `${diffHours} gi·ªù`;
    } else {
      return 'V·ª´a t·∫°o';
    }
  }

  async getDirSize(dirPath) {
    try {
      const { stdout } = await execAsync(`du -sb "${dirPath}"`);
      return parseInt(stdout.split('\t')[0]);
    } catch (error) {
      return 0;
    }
  }

  /**
   * T·∫°o timestamp cho backup
   */
  createTimestamp() {
    return new Date().toISOString().replace(/[:.]/g, '-');
  }

  /**
   * Ki·ªÉm tra y√™u c·∫ßu h·ªá th·ªëng
   */
  async checkSystemRequirements() {
    const requirements = [
      { cmd: 'pg_dump --version', name: 'PostgreSQL Client' },
      { cmd: 'tar --version', name: 'tar command' },
      { cmd: 'gzip --version', name: 'gzip command' }
    ];

    for (const req of requirements) {
      try {
        await execAsync(req.cmd + ' > /dev/null 2>&1');
      } catch (error) {
        throw new Error(`${req.name} kh√¥ng ƒë∆∞·ª£c c√†i ƒë·∫∑t. Vui l√≤ng c√†i ƒë·∫∑t tr∆∞·ªõc khi s·ª≠ d·ª•ng.`);
      }
    }
  }

  /**
   * Test database connection
   */
  async testDatabaseConnection() {
    const testCmd = `PGPASSWORD="${this.dbConfig.password}" psql ` +
      `-h ${this.dbConfig.host} ` +
      `-p ${this.dbConfig.port} ` +
      `-U ${this.dbConfig.user} ` +
      `-d ${this.dbConfig.database} ` +
      `-c "SELECT 1;" > /dev/null 2>&1`;
    
    await execAsync(testCmd);
  }

  /**
   * T·∫°o th∆∞ m·ª•c backup
   */
  ensureBackupDirectory() {
    if (!fs.existsSync(this.backupBaseDir)) {
      fs.mkdirSync(this.backupBaseDir, { recursive: true });
    }
  }

  /**
   * Li·ªát k√™ t·∫•t c·∫£ backup hi·ªán c√≥
   */
  async listBackups() {
    console.log('\nüìã DANH S√ÅCH BACKUP HI·ªÜN C√ì');
    console.log('=' .repeat(80));
    
    if (!fs.existsSync(this.backupBaseDir)) {
      console.log('üìÅ Ch∆∞a c√≥ backup n√†o ƒë∆∞·ª£c t·∫°o');
      return [];
    }
    
    const backups = [];
    const items = fs.readdirSync(this.backupBaseDir);
    
    for (const item of items) {
      const itemPath = path.join(this.backupBaseDir, item);
      const stats = fs.statSync(itemPath);
      
      if (item.endsWith('.tar.gz') || item.startsWith('backup-') || item.startsWith('quick-backup-')) {
        let size = stats.size;
        
        if (stats.isDirectory()) {
          size = await this.getDirSize(itemPath);
        }
        
        backups.push({
          name: item,
          path: itemPath,
          size: size,
          sizeHuman: this.formatBytes(size),
          created: stats.mtime,
          age: this.getAge(stats.mtime),
          type: stats.isDirectory() ? 'folder' : 'archive'
        });
      }
    }
    
    // S·∫Øp x·∫øp theo th·ªùi gian t·∫°o (m·ªõi nh·∫•t tr∆∞·ªõc)
    backups.sort((a, b) => b.created - a.created);
    
    if (backups.length === 0) {
      console.log('üìÅ Ch∆∞a c√≥ backup n√†o ƒë∆∞·ª£c t·∫°o');
      return [];
    }
    
    console.log(`\nüìä T·ªïng c·ªông: ${backups.length} backup\n`);
    
    backups.forEach((backup, index) => {
      const typeIcon = backup.type === 'archive' ? 'üì¶' : 'üìÅ';
      console.log(`${index + 1}. ${typeIcon} ${backup.name}`);
      console.log(`   üíæ Dung l∆∞·ª£ng: ${backup.sizeHuman}`);
      console.log(`   üìÖ T·∫°o l√∫c: ${backup.created.toLocaleString('vi-VN')}`);
      console.log(`   ‚è∞ Tu·ªïi: ${backup.age}`);
      console.log('');
    });
    
    // T√≠nh t·ªïng dung l∆∞·ª£ng
    const totalSize = backups.reduce((sum, backup) => sum + backup.size, 0);
    console.log(`üíæ T·ªïng dung l∆∞·ª£ng: ${this.formatBytes(totalSize)}`);
    
    return backups;
  }

  /**
   * T·∫°o database backup
   */
  async createDatabaseBackup(backupDir, type = 'full') {
    console.log('üóÑÔ∏è  ƒêang backup database...');
    
    const dbBackupDir = path.join(backupDir, 'database');
    fs.mkdirSync(dbBackupDir, { recursive: true });
    
    const timestamp = this.createTimestamp();
    
    if (type === 'full' || type === 'quick') {
      // Full database dump
      const fullDumpFile = path.join(dbBackupDir, `full-dump-${timestamp}.sql`);
      const fullDumpCmd = `PGPASSWORD="${this.dbConfig.password}" pg_dump ` +
        `-h ${this.dbConfig.host} ` +
        `-p ${this.dbConfig.port} ` +
        `-U ${this.dbConfig.user} ` +
        `-d ${this.dbConfig.database} ` +
        `--verbose --clean --if-exists --create ` +
        `--file="${fullDumpFile}"`;
      
      await execAsync(fullDumpCmd);
      await execAsync(`gzip -${this.config.compressionLevel} "${fullDumpFile}"`);
      console.log(`   ‚úÖ Full dump: ${path.basename(fullDumpFile)}.gz`);
    }
    
    if (type === 'full') {
      // Schema-only dump
      const schemaFile = path.join(dbBackupDir, `schema-${timestamp}.sql`);
      const schemaDumpCmd = `PGPASSWORD="${this.dbConfig.password}" pg_dump ` +
        `-h ${this.dbConfig.host} ` +
        `-p ${this.dbConfig.port} ` +
        `-U ${this.dbConfig.user} ` +
        `-d ${this.dbConfig.database} ` +
        `--schema-only --verbose ` +
        `--file="${schemaFile}"`;
      
      await execAsync(schemaDumpCmd);
      await execAsync(`gzip -${this.config.compressionLevel} "${schemaFile}"`);
      console.log(`   ‚úÖ Schema dump: ${path.basename(schemaFile)}.gz`);
      
      // Data-only dump
      const dataFile = path.join(dbBackupDir, `data-${timestamp}.sql`);
      const dataDumpCmd = `PGPASSWORD="${this.dbConfig.password}" pg_dump ` +
        `-h ${this.dbConfig.host} ` +
        `-p ${this.dbConfig.port} ` +
        `-U ${this.dbConfig.user} ` +
        `-d ${this.dbConfig.database} ` +
        `--data-only --verbose ` +
        `--file="${dataFile}"`;
      
      await execAsync(dataDumpCmd);
      await execAsync(`gzip -${this.config.compressionLevel} "${dataFile}"`);
      console.log(`   ‚úÖ Data dump: ${path.basename(dataFile)}.gz`);
    }
    
    return dbBackupDir;
  }

  /**
   * T·∫°o files backup
   */
  async createFilesBackup(backupDir, type = 'full') {
    console.log('üìÅ ƒêang backup files...');
    
    const fileBackupDir = path.join(backupDir, 'files');
    fs.mkdirSync(fileBackupDir, { recursive: true });
    
    // Backup critical files
    const configDir = path.join(fileBackupDir, 'config');
    fs.mkdirSync(configDir, { recursive: true });
    
    for (const file of this.config.criticalFiles) {
      const srcPath = path.join(process.cwd(), file);
      if (fs.existsSync(srcPath)) {
        const destPath = path.join(configDir, path.basename(file));
        fs.copyFileSync(srcPath, destPath);
        console.log(`   ‚úÖ ${file}`);
      }
    }
    
    // Backup directories (ch·ªâ cho full backup)
    if (type === 'full') {
      for (const dir of this.config.backupDirs) {
        try {
          const srcPath = path.join(process.cwd(), dir.src);
          const destPath = path.join(fileBackupDir, dir.dest);
          
          if (fs.existsSync(srcPath)) {
            if (fs.statSync(srcPath).isDirectory()) {
              await execAsync(`cp -r "${srcPath}" "${destPath}"`);
            } else {
              const destDir = path.dirname(destPath);
              if (!fs.existsSync(destDir)) {
                fs.mkdirSync(destDir, { recursive: true });
              }
              fs.copyFileSync(srcPath, destPath);
            }
            console.log(`   ‚úÖ ${dir.src}`);
          } else if (dir.required) {
            console.warn(`   ‚ö†Ô∏è  Required file missing: ${dir.src}`);
          }
        } catch (error) {
          if (dir.required) {
            throw error;
          }
          console.warn(`   ‚ö†Ô∏è  Could not backup ${dir.src}: ${error.message}`);
        }
      }
    } else {
      // Quick backup - ch·ªâ uploads n·∫øu c√≥
      const uploadsDir = path.join(process.cwd(), 'public/uploads');
      if (fs.existsSync(uploadsDir)) {
        await execAsync(`cp -r "${uploadsDir}" "${fileBackupDir}/"`);
        console.log(`   ‚úÖ public/uploads`);
      }
    }
    
    return fileBackupDir;
  }

  /**
   * T·∫°o manifest file
   */
  createManifest(backupDir, type, dbBackupDir, fileBackupDir) {
    const manifest = {
      timestamp: this.createTimestamp(),
      date: new Date().toISOString(),
      type: type,
      version: '2.0',
      database: {
        host: this.dbConfig.host,
        port: this.dbConfig.port,
        database: this.dbConfig.database,
        user: this.dbConfig.user
      },
      files: {
        database: fs.existsSync(dbBackupDir) ? fs.readdirSync(dbBackupDir) : [],
        files: fs.existsSync(fileBackupDir) ? this.getFileList(fileBackupDir) : []
      },
      config: this.config
    };
    
    const manifestFile = path.join(backupDir, 'manifest.json');
    fs.writeFileSync(manifestFile, JSON.stringify(manifest, null, 2));
    
    console.log(`   ‚úÖ Manifest: manifest.json`);
    return manifest;
  }

  /**
   * L·∫•y danh s√°ch files trong th∆∞ m·ª•c
   */
  getFileList(dir, basePath = '') {
    const files = [];
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const relativePath = path.join(basePath, item);
      
      if (fs.statSync(fullPath).isDirectory()) {
        files.push(...this.getFileList(fullPath, relativePath));
      } else {
        const stats = fs.statSync(fullPath);
        files.push({
          path: relativePath,
          size: stats.size,
          modified: stats.mtime.toISOString()
        });
      }
    }
    
    return files;
  }

  /**
   * N√©n backup th√†nh archive
   */
  async compressBackup(backupDir, archiveName) {
    console.log('üì¶ ƒêang n√©n backup...');
    
    const archivePath = path.join(this.backupBaseDir, archiveName);
    const tarCmd = `tar -czf "${archivePath}" -C "${this.backupBaseDir}" "${path.basename(backupDir)}"`;
    
    await execAsync(tarCmd);
    
    // X√≥a th∆∞ m·ª•c t·∫°m
    await execAsync(`rm -rf "${backupDir}"`);
    
    const stats = fs.statSync(archivePath);
    const sizeMB = (stats.size / 1024 / 1024).toFixed(2);
    
    console.log(`   ‚úÖ Archive: ${archiveName} (${sizeMB} MB)`);
    return archivePath;
  }

  /**
   * T·∫°o backup nhanh
   */
  async createQuickBackup() {
    console.log('\n‚ö° T·∫†O BACKUP NHANH');
    console.log('=' .repeat(50));
    
    const timestamp = this.createTimestamp();
    const backupDir = path.join(this.backupBaseDir, `quick-backup-${timestamp}`);
    
    try {
      this.ensureBackupDirectory();
      fs.mkdirSync(backupDir, { recursive: true });
      
      // Database backup
      const dbBackupDir = await this.createDatabaseBackup(backupDir, 'quick');
      
      // Files backup
      const fileBackupDir = await this.createFilesBackup(backupDir, 'quick');
      
      // Manifest
      console.log('üìã T·∫°o manifest...');
      this.createManifest(backupDir, 'quick-backup', dbBackupDir, fileBackupDir);
      
      // Compress
      const archiveName = `quick-backup-${timestamp}.tar.gz`;
      const archivePath = await this.compressBackup(backupDir, archiveName);
      
      console.log('\n‚úÖ BACKUP NHANH HO√ÄN TH√ÄNH!');
      console.log(`üì¶ File: ${archiveName}`);
      console.log(`üìÅ ƒê∆∞·ªùng d·∫´n: ${archivePath}`);
      
      return archivePath;
      
    } catch (error) {
      console.error('‚ùå Backup th·∫•t b·∫°i:', error.message);
      
      // Cleanup on error
      if (fs.existsSync(backupDir)) {
        await execAsync(`rm -rf "${backupDir}"`);
      }
      
      throw error;
    }
  }

  /**
   * T·∫°o backup ƒë·∫ßy ƒë·ªß
   */
  async createFullBackup() {
    console.log('\nüè¢ T·∫†O BACKUP ƒê·∫¶Y ƒê·ª¶');
    console.log('=' .repeat(50));
    
    const timestamp = this.createTimestamp();
    const backupDir = path.join(this.backupBaseDir, `backup-${timestamp}`);
    
    try {
      this.ensureBackupDirectory();
      fs.mkdirSync(backupDir, { recursive: true });
      
      // Database backup
      const dbBackupDir = await this.createDatabaseBackup(backupDir, 'full');
      
      // Files backup
      const fileBackupDir = await this.createFilesBackup(backupDir, 'full');
      
      // Manifest
      console.log('üìã T·∫°o manifest...');
      this.createManifest(backupDir, 'full-backup', dbBackupDir, fileBackupDir);
      
      // Compress
      const archiveName = `backup-${timestamp}.tar.gz`;
      const archivePath = await this.compressBackup(backupDir, archiveName);
      
      console.log('\n‚úÖ BACKUP ƒê·∫¶Y ƒê·ª¶ HO√ÄN TH√ÄNH!');
      console.log(`üì¶ File: ${archiveName}`);
      console.log(`üìÅ ƒê∆∞·ªùng d·∫´n: ${archivePath}`);
      
      return archivePath;
      
    } catch (error) {
      console.error('‚ùå Backup th·∫•t b·∫°i:', error.message);
      
      // Cleanup on error
      if (fs.existsSync(backupDir)) {
        await execAsync(`rm -rf "${backupDir}"`);
      }
      
      throw error;
    }
  }

  /**
   * Ch·ªçn backup ƒë·ªÉ x√≥a
   */
  async selectBackupsToDelete(backups) {
    console.log('\nüóëÔ∏è  CH·ªåN BACKUP ƒê·ªÇ X√ìA');
    console.log('=' .repeat(50));
    console.log('Nh·∫≠p s·ªë th·ª© t·ª± c·ªßa backup mu·ªën x√≥a (c√°ch nhau b·∫±ng d·∫•u ph·∫©y)');
    console.log('V√≠ d·ª•: 1,3,5 ho·∫∑c nh·∫≠p "all" ƒë·ªÉ x√≥a t·∫•t c·∫£');
    console.log('Nh·∫≠p "old" ƒë·ªÉ x√≥a backup c≈© h∆°n 30 ng√†y');
    console.log('Nh·∫≠p "cancel" ƒë·ªÉ h·ªßy\n');
    
    const input = await this.question('L·ª±a ch·ªçn c·ªßa b·∫°n: ');
    
    if (input.toLowerCase() === 'cancel') {
      return [];
    }
    
    if (input.toLowerCase() === 'all') {
      const confirm = await this.question('‚ö†Ô∏è  B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a T·∫§T C·∫¢ backup? (yes/no): ');
      if (confirm.toLowerCase() === 'yes') {
        return backups;
      } else {
        return [];
      }
    }
    
    if (input.toLowerCase() === 'old') {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - this.config.maxBackupAge);
      
      const oldBackups = backups.filter(backup => backup.created < cutoffDate);
      
      if (oldBackups.length === 0) {
        console.log('üìã Kh√¥ng c√≥ backup c≈© n√†o ƒë·ªÉ x√≥a');
        return [];
      }
      
      console.log(`\nüìã T√¨m th·∫•y ${oldBackups.length} backup c≈© h∆°n ${this.config.maxBackupAge} ng√†y:`);
      oldBackups.forEach(backup => {
        console.log(`- ${backup.name} (${backup.sizeHuman}) - ${backup.age}`);
      });
      
      const confirm = await this.question('\n‚ö†Ô∏è  X√°c nh·∫≠n x√≥a c√°c backup c≈©? (yes/no): ');
      if (confirm.toLowerCase() === 'yes') {
        return oldBackups;
      } else {
        return [];
      }
    }
    
    const indices = input.split(',').map(s => parseInt(s.trim()) - 1);
    const selectedBackups = [];
    
    for (const index of indices) {
      if (index >= 0 && index < backups.length) {
        selectedBackups.push(backups[index]);
      }
    }
    
    if (selectedBackups.length === 0) {
      console.log('‚ùå Kh√¥ng c√≥ backup n√†o ƒë∆∞·ª£c ch·ªçn');
      return [];
    }
    
    console.log('\nüìã Backup s·∫Ω b·ªã x√≥a:');
    selectedBackups.forEach(backup => {
      console.log(`- ${backup.name} (${backup.sizeHuman})`);
    });
    
    const confirm = await this.question('\n‚ö†Ô∏è  X√°c nh·∫≠n x√≥a? (yes/no): ');
    if (confirm.toLowerCase() === 'yes') {
      return selectedBackups;
    } else {
      return [];
    }
  }

  /**
   * X√≥a backup
   */
  async deleteBackups(backupsToDelete) {
    console.log('\nüóëÔ∏è  ƒêANG X√ìA BACKUP...');
    
    let deletedCount = 0;
    let freedSpace = 0;
    
    for (const backup of backupsToDelete) {
      try {
        if (backup.type === 'archive') {
          fs.unlinkSync(backup.path);
        } else {
          await execAsync(`rm -rf "${backup.path}"`);
        }
        
        deletedCount++;
        freedSpace += backup.size;
        console.log(`‚úÖ ƒê√£ x√≥a: ${backup.name}`);
      } catch (error) {
        console.error(`‚ùå Kh√¥ng th·ªÉ x√≥a ${backup.name}: ${error.message}`);
      }
    }
    
    console.log(`\nüéâ Ho√†n th√†nh! ƒê√£ x√≥a ${deletedCount} backup`);
    console.log(`üíæ Gi·∫£i ph√≥ng: ${this.formatBytes(freedSpace)}`);
    
    return { deletedCount, freedSpace };
  }

  /**
   * Hi·ªÉn th·ªã th√¥ng tin h·ªá th·ªëng
   */
  async showSystemInfo() {
    console.log('\nüìä TH√îNG TIN H·ªÜ TH·ªêNG');
    console.log('=' .repeat(50));
    
    try {
      // Database info
      console.log('üóÑÔ∏è  Database:');
      console.log(`   Host: ${this.dbConfig.host}:${this.dbConfig.port}`);
      console.log(`   Database: ${this.dbConfig.database}`);
      console.log(`   User: ${this.dbConfig.user}`);
      
      // Disk space
      const { stdout } = await execAsync('df -h .');
      const lines = stdout.trim().split('\n');
      const data = lines[1].split(/\s+/);
      
      console.log('\nüíæ Disk Space:');
      console.log(`   Total: ${data[1]}`);
      console.log(`   Used: ${data[2]} (${data[4]})`);
      console.log(`   Available: ${data[3]}`);
      
      // Backup directory
      console.log('\nüìÅ Backup Directory:');
      console.log(`   Path: ${this.backupBaseDir}`);
      console.log(`   Exists: ${fs.existsSync(this.backupBaseDir) ? 'Yes' : 'No'}`);
      
      if (fs.existsSync(this.backupBaseDir)) {
        const backups = await this.listBackups();
        const totalSize = backups.reduce((sum, backup) => sum + backup.size, 0);
        console.log(`   Backups: ${backups.length}`);
        console.log(`   Total Size: ${this.formatBytes(totalSize)}`);
      }
      
    } catch (error) {
      console.error('‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin h·ªá th·ªëng:', error.message);
    }
  }

  /**
   * Hi·ªÉn th·ªã menu ch√≠nh
   */
  async showMainMenu() {
    console.clear();
    console.log('üéÆ MANUAL BACKUP SYSTEM v2.0');
    console.log('=' .repeat(50));
    console.log('1. üìã Xem danh s√°ch backup');
    console.log('2. ‚ö° T·∫°o backup nhanh (1-2 ph√∫t)');
    console.log('3. üè¢ T·∫°o backup ƒë·∫ßy ƒë·ªß (5-10 ph√∫t)');
    console.log('4. üóëÔ∏è  D·ªçn d·∫πp backup');
    console.log('5. üìä Th√¥ng tin h·ªá th·ªëng');
    console.log('6. üö™ Tho√°t');
    console.log('=' .repeat(50));
    
    const choice = await this.question('Ch·ªçn t√πy ch·ªçn (1-6): ');
    return choice;
  }

  /**
   * Kh·ªüi t·∫°o v√† ki·ªÉm tra h·ªá th·ªëng
   */
  async initialize() {
    console.log('üöÄ KH·ªûI T·∫†O MANUAL BACKUP SYSTEM...\n');
    
    try {
      console.log('üîß Ki·ªÉm tra y√™u c·∫ßu h·ªá th·ªëng...');
      await this.checkSystemRequirements();
      console.log('‚úÖ System requirements OK');
      
      console.log('üîç Ki·ªÉm tra k·∫øt n·ªëi database...');
      await this.testDatabaseConnection();
      console.log('‚úÖ Database connection OK');
      
      console.log('üìÅ Ki·ªÉm tra th∆∞ m·ª•c backup...');
      this.ensureBackupDirectory();
      console.log('‚úÖ Backup directory OK');
      
      console.log('\nüéâ H·ªá th·ªëng s·∫µn s√†ng!\n');
      return true;
      
    } catch (error) {
      console.error('‚ùå L·ªói kh·ªüi t·∫°o:', error.message);
      console.log('\nüîß Vui l√≤ng ki·ªÉm tra:');
      console.log('1. PostgreSQL client tools ƒë√£ ƒë∆∞·ª£c c√†i ƒë·∫∑t');
      console.log('2. DATABASE_URL trong .env ƒë√£ ƒë√∫ng');
      console.log('3. Database server ƒëang ch·∫°y');
      console.log('4. Quy·ªÅn ghi v√†o th∆∞ m·ª•c project');
      return false;
    }
  }

  /**
   * Main loop
   */
  async run() {
    try {
      const initialized = await this.initialize();
      if (!initialized) {
        this.rl.close();
        process.exit(1);
      }
      
      while (true) {
        const choice = await this.showMainMenu();
        
        switch (choice) {
          case '1':
            await this.listBackups();
            await this.question('\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...');
            break;
            
          case '2':
            try {
              await this.createQuickBackup();
            } catch (error) {
              console.error('‚ùå L·ªói:', error.message);
            }
            await this.question('\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...');
            break;
            
          case '3':
            try {
              await this.createFullBackup();
            } catch (error) {
              console.error('‚ùå L·ªói:', error.message);
            }
            await this.question('\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...');
            break;
            
          case '4':
            const backups = await this.listBackups();
            if (backups.length > 0) {
              const backupsToDelete = await this.selectBackupsToDelete(backups);
              if (backupsToDelete.length > 0) {
                await this.deleteBackups(backupsToDelete);
              }
            }
            await this.question('\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...');
            break;
            
          case '5':
            await this.showSystemInfo();
            await this.question('\nNh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...');
            break;
            
          case '6':
            console.log('\nüëã T·∫°m bi·ªát!');
            this.rl.close();
            return;
            
          default:
            console.log('\n‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!');
            await this.question('Nh·∫•n Enter ƒë·ªÉ ti·∫øp t·ª•c...');
        }
      }
      
    } catch (error) {
      console.error('‚ùå L·ªói h·ªá th·ªëng:', error.message);
      this.rl.close();
      process.exit(1);
    }
  }
}

// Export class
module.exports = ManualBackupSystem;

// Ch·∫°y n·∫øu ƒë∆∞·ª£c g·ªçi tr·ª±c ti·∫øp
if (require.main === module) {
  const backupSystem = new ManualBackupSystem();
  backupSystem.run().catch(error => {
    console.error('‚ùå L·ªói:', error.message);
    process.exit(1);
  });
}